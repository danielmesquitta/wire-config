package usecase

import (
	"bufio"
	"fmt"
	"go/format"
	"io"
	"os"
	"path"
	"strings"
	"text/template"

	"github.com/ettle/strcase"
)

type wireConfigData struct {
	PackageName      string
	Imports          []string
	DefaultProviders []string
	Environments     []environmentConfig
}

type environmentConfig struct {
	Name      string
	Providers []string
	Params    []string
}

// Use a text/template to generate the final wire.go.
var wireTemplate = `// Code generated by Wire. DO NOT EDIT.

//go:build wireinject
// +build wireinject

package {{.PackageName}}

import (
{{- range .Imports }}
    "{{.}}"
{{- end }}
)

{{- range .Environments }}
// New{{ .Name }} wires up the application in {{ .Name | lower }} mode.
func New{{ .Name }}(
{{- range .Params }}
    {{.}},
{{- end }}
) *App {
    wire.Build(
  {{- range .Providers }}
      {{.}}
  {{- end }}
    )
    return &App{}
}
{{- end }}
`

func ParseWireConfig(
	configFile,
	outFile,
	mainPackageImport string,
	environmentNames []string,
) error {
	environmentNames, err := parseEnvironmentNames(environmentNames)
	if err != nil {
		return err
	}

	data, err := parseWireConfig(
		configFile,
		mainPackageImport,
		environmentNames,
	)
	if err != nil {
		return err
	}

	err = generateWireFile(outFile, data)
	if err != nil {
		return err
	}

	fmt.Printf("wire: wrote %s\n", outFile)
	return nil
}

func parseEnvironmentNames(environmentNames []string) ([]string, error) {
	if len(environmentNames) == 0 {
		return []string{"Prod"}, nil
	}

	parsed := make([]string, len(environmentNames))
	for i, env := range environmentNames {
		env = strings.TrimSpace(env)
		if env == "" {
			return nil, fmt.Errorf("environment name cannot be empty")
		}
		parsed[i] = strcase.ToPascal(env)
	}

	return parsed, nil
}

// parseWireConfig reads wire_config.go line by line
func parseWireConfig(
	filename, mainPackageImport string,
	environmentNames []string,
) (*wireConfigData, error) {
	file, err := os.Open(filename)
	if err != nil {
		return nil, err
	}
	defer file.Close()

	packageName := path.Base(mainPackageImport)

	data := &wireConfigData{
		PackageName:      packageName,
		Imports:          []string{},
		DefaultProviders: []string{},
		Environments:     []environmentConfig{},
	}

	scanner := bufio.NewScanner(file)

	inImportBlock := false
	inParamsBlock := false
	currentSection := ""

	// Map to track provider sections and their corresponding slices
	providerSections := map[string]*[]string{
		"var providers = []any{": &data.DefaultProviders,
	}
	params := []string{}

	environments := map[string]*environmentConfig{}
	for _, env := range environmentNames {
		envConfig := environmentConfig{
			Name:      env,
			Providers: []string{},
		}
		environments[env] = &envConfig

		key := fmt.Sprintf("var %sProviders = []any{", strings.ToLower(env))
		providerSections[key] = &envConfig.Providers
	}

	// Keep track of imports in a set to avoid duplicates
	importSet := make(map[string]bool)

	for scanner.Scan() {
		line := scanner.Text()
		line = strings.TrimSpace(line)

		// Detect start/end of import block
		if strings.HasPrefix(line, "import (") {
			inImportBlock = true
			continue
		}
		if inImportBlock && strings.HasPrefix(line, ")") {
			inImportBlock = false
			continue
		}

		// Inside import block
		if inImportBlock {
			impLine := strings.Trim(line, `"`)
			impLine = strings.TrimSpace(impLine)
			if impLine == "" || strings.HasPrefix(impLine, "(") ||
				strings.HasPrefix(impLine, ")") {
				continue
			}
			// Skip the main package import
			if impLine == mainPackageImport {
				continue
			}
			// De-duplicate imports
			if _, seen := importSet[impLine]; !seen {
				importSet[impLine] = true
				data.Imports = append(data.Imports, impLine)
			}
			continue
		}

		// Detect start/end of params block
		if strings.HasPrefix(line, "func params(") {
			inParamsBlock = true
			continue
		}

		if inParamsBlock && strings.HasPrefix(line, ") {") {
			inParamsBlock = false
			continue
		}

		if inParamsBlock {
			paramLine := strings.TrimSpace(line)
			paramLine = strings.TrimSuffix(paramLine, ",")
			params = append(params, paramLine)
		}

		// Check if this line starts a provider section
		for prefix := range providerSections {
			if strings.HasPrefix(line, prefix) {
				currentSection = prefix
				break
			}
		}

		// End of a section
		if line == "}" && currentSection != "" {
			currentSection = ""
			continue
		}

		// Process content within a provider section
		if currentSection != "" && line != currentSection {
			trimmed := strings.TrimSpace(line)
			if trimmed != "" && trimmed != "}" {
				// Get the slice pointer for this section and append to it
				if slice, ok := providerSections[currentSection]; ok {
					// Remove main package reference from provider
					if strings.HasPrefix(trimmed, packageName) {
						trimmed = strings.Replace(
							trimmed,
							packageName+".",
							"",
							1,
						)
					}
					*slice = append(*slice, trimmed)
				}
			}
		}
	}

	if err := scanner.Err(); err != nil {
		return nil, err
	}

	for _, env := range environments {
		providers := append(env.Providers, data.DefaultProviders...)

		data.Environments = append(data.Environments, environmentConfig{
			Name:      env.Name,
			Providers: providers,
			Params:    params,
		})
	}

	return data, nil
}

func generateWireFile(outputFilename string, data *wireConfigData) error {
	// Add custom function to template for converting to lowercase
	funcMap := template.FuncMap{
		"lower": strings.ToLower,
	}

	tmpl, err := template.New("wire").Funcs(funcMap).Parse(wireTemplate)
	if err != nil {
		return err
	}

	gff := &GoFileFormatter{}
	if err := tmpl.Execute(gff, data); err != nil {
		return err
	}

	if err := gff.Format(); err != nil {
		return err
	}

	if err := os.WriteFile(outputFilename, gff.Bytes(), 0644); err != nil {
		return err
	}

	return nil
}

type GoFileFormatter struct {
	data []byte
}

func (f *GoFileFormatter) Write(p []byte) (n int, err error) {
	f.data = append(f.data, p...)
	return len(p), nil
}

func (f *GoFileFormatter) Format() error {
	formatted, err := format.Source(f.data)
	if err != nil {
		return err
	}
	f.data = formatted
	return nil
}

func (f *GoFileFormatter) Bytes() []byte {
	return f.data
}

var _ io.Writer = &GoFileFormatter{}
